"""
@name: _graphs.py                        
@description:                  
    Module for building and aggregating graphs

    Can be imported with toolbox.graphs

@author: Christopher Brittin   
@email: "cabrittin"+ <at>+ "gmail"+ "."+ "com"
@date: 2019-12-05              
"""

import numpy as np
import networkx as nx

def consensus(H,_deg,nodes=None,weight=['weight']):
    """
    Make degree consensus consensus graphs. 
    
    Looks for edges found in only n=deg number of H graphs

    Input:
    ------
    H : List of networkx graphs, All graphs assumed to be either directed or undirected
    deg: int, number of graphs required to have edge
    nodes: list, optional (default: None)
        List of nodes to build consensus graphs. If None, consensus nodes are used.

    """
    if nodes is None: nodes = composite_nodes(H)
    G = H[0].__class__()
    n = len(nodes)
    k = len(H)
    ndict = dict([(i,j) for (i,j) in enumerate(nodes)])
    for w in weight:
        Z = np.zeros([k,n,n])
        for (i,h) in enumerate(H):
            for _n in nodes:
                if not h.has_node(_n): h.add_node(_n)
            Z[i,:,:] = nx.to_numpy_array(h,nodelist=nodes,weight=w)
        deg = np.count_nonzero(Z,axis=0)
        S = Z.sum(axis=0)
        nz = np.nonzero(deg)
        S[nz] = np.divide(S[nz],deg[nz])
        for (i,j) in zip(*np.where(deg == _deg)):
            if not G.has_edge(nodes[i],nodes[j]): G.add_edge(nodes[i],nodes[j])
            G[nodes[i]][nodes[j]][w] = S[i,j]
    return G

def composite_nodes(H):
    """
    Get the composite nodes of a list of graphs
    
    Input:
    ------
    H : List of networkx graphs
    
    Returns:
    --------
    nodes: list,
        List of all nodes in the graphs of H
    """
    nodes = set([])
    for h in H: nodes = nodes | set(list(h.nodes()))
    return list(nodes)


def index_merge(G):
    """
    Merges list of graphs into a single multi-graph, where the edges are indexed with the 
    'id' attribute 

    Inputs:
    -------
    G: List of `ordered' graphs. Note all
        graphs are assumed to be either directed or undirected
    
    """
    H = G[0].__class__()
    for (i,g) in enumerate(G):
        nx.set_edge_attributes(g,i+1,'id')
        H.add_edges_from((n, nbr, d)
            for n, nbrs in g.adj.items()
            for nbr, d in nbrs.items())
    return H

   
def zip_index_consensus_graph_edges(C,G):
    """
    Given a consensus graph C and a list the list of graphs G used to build the consensus graph,
    adds edge attributes 'g_index' and 'g_index_weight', which identifies the graph (by index) and 
    the associated edge weights in each graph.

    g_index:= is string 'g_1-g_2-g_3...' where g_i is the ith list position from G if G[i] has the
    the associated edge

    g_index_weight:= is string 'w_1-w_2-w_3...' where w_i is the edge weight from graph g_i

    Inputs:
    -------
    C: networkx Graph
        Consensus graph generated by function `consensus'

    G: List of `ordered' graphs. Note all
        graphs are assumed to be either directed or undirected
    
    """
    for (u,v) in C.edges():
        g_index,g_index_weight = [],[]
        for (i,g) in enumerate(G):
            if g.has_edge(u,v):
                g_index.append(i)
                g_index_weight.append(g[u][v]['weight'])
        if len(g_index) > 0: 
            C[u][v]['g_index'] = '-'.join(map(str,g_index))
            C[u][v]['g_index_weight'] = '-'.join(map(str,g_index_weight))


def unzip_index_consensus_graph_edges(C):
    """
    Takes a consensus graph that has passed through zip_index_consensus_graph_edges and
    returns list of graphs used to construct the consensus graph

    Inputs:
    -------
    C: networkx Graph
        Consensus graph that has passed through zip_index_consensus_graph_edges
    
    Returns:
    --------
    G: List of networkx graphs used to construct consensus graph
    
    """
    graphs = {}
    for (u,v) in C.edges():
        g_index = list(map(int,C[u][v]['g_index'].split('-')))
        g_index_weight = list(map(int,C[u][v]['g_index_weight'].split('-')))
        for (idx,w) in zip(g_index,g_index_weight):
            if idx not in graphs: 
                graphs[idx] = nx.Graph()
                if C.is_directed(): graphs[idx] = nx.DiGraph()
            graphs[idx].add_edge(u,v,weight=w)
    return [graphs[k] for k in sorted(graphs.keys())]



   

